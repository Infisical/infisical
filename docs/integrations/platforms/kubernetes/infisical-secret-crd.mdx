---
sidebarTitle: "InfisicalSecret CRD"
title: "Using the InfisicalSecret CRD"
description: "Learn how to use the InfisicalSecret CRD to fetch secrets from Infisical and store them as native Kubernetes secret resource"
---

Once you have installed the operator to your cluster, you'll need to create a `InfisicalSecret` custom resource definition (CRD).
In this CRD, you'll define the authentication method to use, the secrets to fetch, and the target location to store the secrets within your cluster.

```yaml example-infisical-secret-crd.yaml
apiVersion: secrets.infisical.com/v1alpha1
kind: InfisicalSecret
metadata:
  name: infisicalsecret-sample
  labels:
    label-to-be-passed-to-managed-secret: sample-value
  annotations:
    example.com/annotation-to-be-passed-to-managed-secret: "sample-value"
spec:
  hostAPI: https://app.infisical.com/api
  resyncInterval: 10
  authentication:
    kubernetesAuth:
      identityId: <machine-identity-id>
      serviceAccountRef:
        name: <service-account-name>
        namespace: <service-account-namespace>

  managedSecretReference:
    secretName: managed-secret
    secretNamespace: default
    creationPolicy: "Orphan"
    template:
      includeAllSecrets: true
      data:
        NEW_KEY_NAME: "{{ .KEY.SecretPath }} {{ .KEY.Value }}"
        KEY_WITH_BINARY_VALUE: "{{ .KEY.SecretPath }} {{ .KEY.Value }}"
```

## CRD properties

### Generic

The following properties help define what instance of Infisical the operator will interact with, the interval it will sync secrets and any CA certificates that may be required to connect.

<Accordion title="hostAPI">
  If you are fetching secrets from a self-hosted instance of Infisical set the value of `hostAPI` to 
  ` https://your-self-hosted-instace.com/api`

When `hostAPI` is not defined the operator fetches secrets from Infisical Cloud.

  <Accordion title="Advanced use case">
    If you have installed your Infisical instance within the same cluster as the Infisical operator, you can optionally access the Infisical backend's service directly without having to route through the public internet. 
    To achieve this, use the following address for the hostAPI field:
    
    ``` bash
    http://<backend-svc-name>.<namespace>.svc.cluster.local:4000/api
    ```

    Make sure to replace `<backend-svc-name>` and `<namespace>` with the appropriate values for your backend service and namespace.

  </Accordion>
</Accordion>

<Accordion title="resyncInterval">
  This property defines the time in seconds between each secret re-sync from
  Infisical. Shorter time between re-syncs will require higher rate limits only
  available on paid plans. Default re-sync interval is every 1 minute.
</Accordion>

<Accordion title="tls">
  This block defines the TLS settings to use for connecting to the Infisical
  instance.
</Accordion>

<Accordion title="tls.caRef">
  This block defines the reference to the CA certificate to use for connecting
  to the Infisical instance with SSL/TLS.
</Accordion>

<Accordion title="tls.caRef.secretName">
  The name of the Kubernetes secret containing the CA certificate to use for
  connecting to the Infisical instance with SSL/TLS.
</Accordion>

<Accordion title="tls.caRef.secretNamespace">
  The namespace of the Kubernetes secret containing the CA certificate to use
  for connecting to the Infisical instance with SSL/TLS.
</Accordion>

<Accordion title="tls.caRef.key">
  The name of the key in the Kubernetes secret which contains the value of the
  CA certificate to use for connecting to the Infisical instance with SSL/TLS.
</Accordion>

### Authentication methods

To retrieve the requested secrets, the operator must first authenticate with Infisical.
The list of available authentication methods are shown below.

<Accordion title="authentication"></Accordion>

<Accordion title="authentication.universalAuth">
  The universal machine identity authentication method is used to authenticate with Infisical. The client ID and client secret needs to be stored in a Kubernetes secret. This block defines the reference to the name and namespace of secret that stores these credentials.

  <Steps>
    <Step title="Create a machine identity">
      You need to create a machine identity, and give it access to the project(s) you want to interact with. You can [read more about machine identities here](/documentation/platform/identities/universal-auth).
    </Step>
    <Step title="Create Kubernetes secret containing machine identity credentials">
      Once you have created your machine identity and added it to your project(s), you will need to create a Kubernetes secret containing the identity credentials.
      To quickly create a Kubernetes secret containing the identity credentials, you can run the command below.
      
      Make sure you replace `<your-identity-client-id>` with the identity client ID and `<your-identity-client-secret>` with the identity client secret.

      ``` bash
        kubectl create secret generic universal-auth-credentials --from-literal=clientId="<your-identity-client-id>" --from-literal=clientSecret="<your-identity-client-secret>"
      ```
    </Step>

    <Step title="Add reference for the Kubernetes secret containing the identity credentials">
      Once the secret is created, add the `secretName` and `secretNamespace` of the secret that was just created under `authentication.universalAuth.credentialsRef` field in the InfisicalSecret resource.
    </Step>

  </Steps>

<Info>
  Make sure to also populate the `secretsScope` field with the project slug
  _`projectSlug`_, environment slug _`envSlug`_, and secrets path
  _`secretsPath`_ that you want to fetch secrets from. Please see the example
  below.
</Info>

## Example

```yaml
apiVersion: secrets.infisical.com/v1alpha1
kind: InfisicalSecret
metadata:
  name: infisicalsecret-sample-crd
spec:
  authentication:
      universalAuth:
          secretsScope:
              projectSlug: <project-slug> # <-- project slug
              envSlug: <env-slug> # "dev", "staging", "prod", etc..
              secretsPath: "<secrets-path>" # Root is "/"
          credentialsRef:
              secretName: universal-auth-credentials # <-- name of the Kubernetes secret that stores our machine identity credentials
              secretNamespace: default # <-- namespace of the Kubernetes secret that stores our machine identity credentials
  ...
```

</Accordion>

<Accordion title="authentication.kubernetesAuth">
  The Kubernetes machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used within a Kubernetes environment.

  <Steps>
    <Step title="Obtaining the token reviewer JWT for Infisical">
        1.1. Start by creating a service account in your Kubernetes cluster that will be used by Infisical to authenticate with the Kubernetes API Server.

        ```yaml infisical-service-account.yaml
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: infisical-auth
          namespace: default

        ```

        ```
        kubectl apply -f infisical-service-account.yaml
        ```

        1.2. Bind the service account to the `system:auth-delegator` cluster role. As described [here](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#other-component-roles), this role allows delegated authentication and authorization checks, specifically for Infisical to access the [TokenReview API](https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-review-v1/). You can apply the following configuration file:

        ```yaml cluster-role-binding.yaml
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRoleBinding
        metadata:
          name: role-tokenreview-binding
          namespace: default
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: system:auth-delegator
        subjects:
          - kind: ServiceAccount
            name: infisical-auth
            namespace: default
        ```

        ```
        kubectl apply -f cluster-role-binding.yaml
        ```

        1.3. Next, create a long-lived service account JWT token (i.e. the token reviewer JWT token) for the service account using this configuration file for a new `Secret` resource:

        ```yaml service-account-token.yaml
        apiVersion: v1
        kind: Secret
        type: kubernetes.io/service-account-token
        metadata:
          name: infisical-auth-token
          annotations:
            kubernetes.io/service-account.name: "infisical-auth"
        ```


        ```
        kubectl apply -f service-account-token.yaml
        ```

        1.4. Link the secret in step 1.3 to the service account in step 1.1:

        ```bash
        kubectl patch serviceaccount infisical-auth -p '{"secrets": [{"name": "infisical-auth-token"}]}' -n default
        ```

        1.5. Finally, retrieve the token reviewer JWT token from the secret.

        ```bash
        kubectl get secret infisical-auth-token -n default -o=jsonpath='{.data.token}' | base64 --decode
        ```

        Keep this JWT token handy as you will need it for the **Token Reviewer JWT** field when configuring the Kubernetes Auth authentication method for the identity in step 2.

    </Step>

    <Step title="Creating an identity">
      To create an identity, head to your Organization Settings > Access Control > Machine Identities and press **Create identity**.

      ![identities organization](/images/platform/identities/identities-org.png)

      When creating an identity, you specify an organization level [role](/documentation/platform/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

      ![identities organization create](/images/platform/identities/identities-org-create.png)

      Now input a few details for your new identity. Here's some guidance for each field:

      - Name (required): A friendly name for the identity.
      - Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

      Once you've created an identity, you'll be prompted to configure the authentication method for it. Here, select **Kubernetes Auth**.

      <Info>
        To learn more about each field of the Kubernetes native authentication method, see step 2 of [guide](/documentation/platform/identities/kubernetes-auth#guide).
      </Info>

      ![identities organization create auth method](/images/platform/identities/identities-org-create-kubernetes-auth-method.png)


    </Step>
    <Step title="Adding an identity to a project">
      To allow the operator to use the given identity to access secrets, you will need to add the identity to project(s) that you would like  to grant it access to.

      To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

      Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

      ![identities project](/images/platform/identities/identities-project.png)

      ![identities project create](/images/platform/identities/identities-project-create.png)

    </Step>
    <Step title="Add your identity ID & service account to your InfisicalSecret resource">
      Once you have created your machine identity and added it to your project(s), you will need to add the identity ID to your InfisicalSecret resource.
      In the `authentication.kubernetesAuth.identityId` field, add the identity ID of the machine identity you created.
      See the example below for more details.
    </Step>
    <Step title="Add your Kubernetes service account token to the InfisicalSecret resource">
      Add the service account details from the previous steps under `authentication.kubernetesAuth.serviceAccountRef`.
      Here you will need to enter the name and namespace of the service account.
      The example below shows a complete InfisicalSecret resource with all required fields defined.
    </Step>

  </Steps>

<Info>
  Make sure to also populate the `secretsScope` field with the project slug
  _`projectSlug`_, environment slug _`envSlug`_, and secrets path
  _`secretsPath`_ that you want to fetch secrets from. Please see the example
  below.
</Info>

## Example

```yaml example-kubernetes-auth.yaml
apiVersion: secrets.infisical.com/v1alpha1
kind: InfisicalSecret
metadata:
  name: infisicalsecret-sample-crd
spec:
  authentication:
      kubernetesAuth:
          identityId: <machine-identity-id>
          serviceAccountRef:
            name: <service-account-name>
            namespace: <service-account-namespace>

          # secretsScope is identical to the secrets scope in the universalAuth field in this sample.
          secretsScope:
              projectSlug: your-project-slug
              envSlug: prod
              secretsPath: "/path"
              recursive: true
  ...
```

</Accordion>

<Accordion title="authentication.awsIamAuth">
  The AWS IAM machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used within an AWS environment like an EC2 or a Lambda function.

  <Steps>
    <Step title="Create a machine identity">
      You need to create a machine identity, and give it access to the project(s) you want to interact with. You can [read more about AWS machine identities here](/documentation/platform/identities/aws-auth).
    </Step>
    <Step title="Add your identity ID to your InfisicalSecret resource">
      Once you have created your machine identity and added it to your project(s), you will need to add the identity ID to your InfisicalSecret resource. In the `authentication.awsIamAuth.identityId` field, add the identity ID of the machine identity you created. See the example below for more details.
    </Step>

  </Steps>

<Info>
  Make sure to also populate the `secretsScope` field with the project slug
  _`projectSlug`_, environment slug _`envSlug`_, and secrets path
  _`secretsPath`_ that you want to fetch secrets from. Please see the example
  below.
</Info>

## Example

```yaml example-aws-iam-auth.yaml
apiVersion: secrets.infisical.com/v1alpha1
kind: InfisicalSecret
metadata:
  name: infisicalsecret-sample-crd
spec:
  authentication:
      awsIamAuth:
          identityId: <your-machine-identity-id>

          # secretsScope is identical to the secrets scope in the universalAuth field in this sample.
          secretsScope:
              projectSlug: your-project-slug
              envSlug: prod
              secretsPath: "/path"
              recursive: true
  ...
```

</Accordion>

<Accordion title="authentication.azureAuth">
  The Azure machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used within an Azure environment.

  <Steps>
    <Step title="Create a machine identity">
      You need to create a machine identity, and give it access to the project(s) you want to interact with. You can [read more about Azure machine identities here](/documentation/platform/identities/azure-auth).
    </Step>
    <Step title="Add your identity ID to your InfisicalSecret resource">
      Once you have created your machine identity and added it to your project(s), you will need to add the identity ID to your InfisicalSecret resource. In the `authentication.azureAuth.identityId` field, add the identity ID of the machine identity you created. See the example below for more details.
    </Step>

  </Steps>

<Info>
  Make sure to also populate the `secretsScope` field with the project slug
  _`projectSlug`_, environment slug _`envSlug`_, and secrets path
  _`secretsPath`_ that you want to fetch secrets from. Please see the example
  below.
</Info>

## Example

```yaml example-azure-auth.yaml
apiVersion: secrets.infisical.com/v1alpha1
kind: InfisicalSecret
metadata:
  name: infisicalsecret-sample-crd
spec:
  authentication:
      azureAuth:
          identityId: <your-machine-identity-id>

          # secretsScope is identical to the secrets scope in the universalAuth field in this sample.
          secretsScope:
              projectSlug: your-project-slug
              envSlug: prod
              secretsPath: "/path"
              recursive: true
  ...
```

</Accordion>

<Accordion title="authentication.gcpIdTokenAuth">
  The GCP ID Token machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used within GCP environments.

  <Steps>
    <Step title="Create a machine identity">
      You need to create a machine identity, and give it access to the project(s) you want to interact with. You can [read more about GCP machine identities here](/documentation/platform/identities/gcp-auth).
    </Step>
    <Step title="Add your identity ID to your InfisicalSecret resource">
      Once you have created your machine identity and added it to your project(s), you will need to add the identity ID to your InfisicalSecret resource. In the `authentication.gcpIdTokenAuth.identityId` field, add the identity ID of the machine identity you created. See the example below for more details.
    </Step>

  </Steps>

<Info>
  Make sure to also populate the `secretsScope` field with the project slug
  _`projectSlug`_, environment slug _`envSlug`_, and secrets path
  _`secretsPath`_ that you want to fetch secrets from. Please see the example
  below.
</Info>

## Example

```yaml example-gcp-id-token-auth.yaml
apiVersion: secrets.infisical.com/v1alpha1
kind: InfisicalSecret
metadata:
  name: infisicalsecret-sample-crd
spec:
  authentication:
      gcpIdTokenAuth:
          identityId: <your-machine-identity-id>

          # secretsScope is identical to the secrets scope in the universalAuth field in this sample.
          secretsScope:
              projectSlug: your-project-slug
              envSlug: prod
              secretsPath: "/path"
              recursive: true
  ...
```

</Accordion>

<Accordion title="authentication.gcpIamAuth">
  The GCP IAM machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used both within and outside GCP environments.

  <Steps>
    <Step title="Create a machine identity">
      You need to create a machine identity, and give it access to the project(s) you want to interact with. You can [read more about GCP machine identities here](/documentation/platform/identities/gcp-auth).
    </Step>
    <Step title="Add your identity ID and service account token path to your InfisicalSecret resource">
      Once you have created your machine identity and added it to your project(s), you will need to add the identity ID to your InfisicalSecret resource. In the `authentication.gcpIamAuth.identityId` field, add the identity ID of the machine identity you created.
      You'll also need to add the service account key file path to your InfisicalSecret resource. In the `authentication.gcpIamAuth.serviceAccountKeyFilePath` field, add the path to your service account key file path. Please see the example below for more details.
    </Step>

  </Steps>

<Info>
  Make sure to also populate the `secretsScope` field with the project slug
  _`projectSlug`_, environment slug _`envSlug`_, and secrets path
  _`secretsPath`_ that you want to fetch secrets from. Please see the example
  below.
</Info>

## Example

```yaml example-gcp-id-token-auth.yaml
apiVersion: secrets.infisical.com/v1alpha1
kind: InfisicalSecret
metadata:
  name: infisicalsecret-sample-crd
spec:
  authentication:
      gcpIamAuth:
          identityId: <your-machine-identity-id>
          serviceAccountKeyFilePath: "/path/to-service-account-key-file-path.json"

          # secretsScope is identical to the secrets scope in the universalAuth field in this sample.
          secretsScope:
              projectSlug: your-project-slug
              envSlug: prod
              secretsPath: "/path"
              recursive: true
  ...
```

</Accordion>

<Accordion title="authentication.serviceToken">

The service token required to authenticate with Infisical needs to be stored in a Kubernetes secret. This block defines the reference to the name and namespace of secret that stores this service token.
Follow the instructions below to create and store the service token in a Kubernetes secrets and reference it in your CRD.

#### 1. Generate service token

You can generate a [service token](../../documentation/platform/token) for an Infisical project by heading over to the Infisical dashboard then to Project Settings.

#### 2. Create Kubernetes secret containing service token

Once you have generated the service token, you will need to create a Kubernetes secret containing the service token you generated.
To quickly create a Kubernetes secret containing the generated service token, you can run the command below. Make sure you replace `<your-service-token-here>` with your service token.

```bash
kubectl create secret generic service-token --from-literal=infisicalToken="<your-service-token-here>"
```

#### 3. Add reference for the Kubernetes secret containing service token

Once the secret is created, add the name and namespace of the secret that was just created under `authentication.serviceToken.serviceTokenSecretReference` field in the InfisicalSecret resource.

{" "}

<Info>
  Make sure to also populate the `secretsScope` field with the, environment slug
  _`envSlug`_, and secrets path _`secretsPath`_ that you want to fetch secrets
  from. Please see the example below.
</Info>

## Example

```yaml
apiVersion: secrets.infisical.com/v1alpha1
kind: InfisicalSecret
metadata:
  name: infisicalsecret-sample-crd
spec:
  authentication:
    serviceToken:
      serviceTokenSecretReference:
        secretName: service-token # <-- name of the Kubernetes secret that stores our service token
        secretNamespace: option # <-- namespace of the Kubernetes secret that stores our service token
      secretsScope:
        envSlug: <env-slug> # "dev", "staging", "prod", etc..
        secretsPath: <secrets-path> # Root is "/"
  ...
```

</Accordion>

### Operator managed secrets

The managed secret properties specify where to store the secrets retrieved from your Infisical project.
This includes defining the name and namespace of the Kubernetes secret that will hold these secrets.
The Infisical operator will automatically create the Kubernetes secret in the specified name/namespace and ensure it stays up-to-date.

<Accordion title="managedSecretReference">
</Accordion>
<Accordion title="managedSecretReference.secretName">
The name of the managed Kubernetes secret to be created
</Accordion>
<Accordion title="managedSecretReference.secretNamespace">
The namespace of the managed Kubernetes secret to be created. 
</Accordion>
<Accordion title="managedSecretReference.secretType">
Override the default Opaque type for managed secrets with this field. Useful for creating kubernetes.io/dockerconfigjson secrets.
</Accordion>
<Accordion title="managedSecretReference.creationPolicy">
Creation polices allow you to control whether or not owner references should be added to the managed Kubernetes secret that is generated by the Infisical operator. 
This is useful for tools such as ArgoCD, where every resource requires an owner reference; otherwise, it will be pruned automatically.

#### Available options

- `Orphan` (default)
- `Owner`

<Tip>
  When creation policy is set to `Owner`, the `InfisicalSecret` CRD must be in
  the same namespace as where the managed kubernetes secret.
</Tip>

</Accordion>

### Manged secret templating

Fetching secrets from Infisical as is via the operator may not be enough. This is where templating functionality may be helpful.
Using Go templates, you can format, combine, and create new key-value pairs from secrets fetched from Infisical before storing them as Kubernetes Secrets.

<Accordion title="managedSecretReference.template">
</Accordion>
<Accordion title="managedSecretReference.template.includeAllSecrets">
  This property controls what secrets are included in your managed secret when using templates. 
  When set to `true`, all secrets fetched from your Infisical project will be added into your managed Kubernetes secret resource. 
  **Use this option when you would like to sync all secrets from Infisical to Kubernetes but want to template a subset of them.**

When set to `false`, only secrets defined in the `managedSecretReference.template.data` field of the template will be included in the managed secret.
Use this option when you would like to sync **only** a subset of secrets from Infisical to Kubernetes.

</Accordion>
<Accordion title="managedSecretReference.template.data">
Define secret keys and their corresponding templates. 
Each data value uses a Golang template with access to all secrets retrieved from the specified scope.

Secrets are structured as follows:

```golang
type TemplateSecret struct {
    Value      string `json:"value"`
    SecretPath string `json:"secretPath"`
}
```

#### Example template configuration:

```yaml
managedSecretReference:
  secretName: managed-secret
  secretNamespace: default
  template:
    includeAllSecrets: true
    data:
      # Create new secret key that doesn't exist in your Infisical project using values of other secrets
      NEW_KEY: "{{ .DB_PASSWORD.Value }}"
      # Override an existing secret key in Infisical project with a new value using values of other secrets
      API_URL: "https://api.{{.COMPANY_NAME.Value}}.{{.REGION.Value}}.com"
```

For this example, let's assume the following secrets exist in your Infisical project:

```
DB_PASSWORD = "secret123"
COMPANY_NAME = "acme"
REGION = "us-east-1"
API_URL = "old-url"  # This will be overridden
```

The resulting managed Kubernetes secret will then contain:

```
# Original secrets (from includeAllSecrets: true)
DB_PASSWORD = "secret123"
COMPANY_NAME = "acme"
REGION = "us-east-1"

# New and overridden templated secrets
NEW_KEY = "secret123"                       # New secret created from template
API_URL = "https://api.acme.us-east-1.com" # Existing secret overridden by template
```

To help transform your secrets further, the operator provides a set of built-in functions that you can use in your templates.

### Available templating functions

<Accordion title="decodeBase64ToBytes">
  **Function name**: decodeBase64ToBytes

**Description**:
Given a base64 encoded string, this function will decodes the base64-encoded string.
This function is useful when your secrets are already stored as base64 encoded value in Infisical.

**Returns**: The decoded base64 string as bytes.

**Example**:
The example below assumes that the `BINARY_KEY_BASE64` secret is stored as a base64 encoded value in Infisical.
The resulting managed secret will contain the decoded value of `BINARY_KEY_BASE64`.

```yaml
managedSecretReference:
secretName: managed-secret
secretNamespace: default
template:
  includeAllSecrets: true
  data:
    BINARY_KEY: "{{ decodeBase64ToBytes .BINARY_KEY_BASE64.Value }}"
```

</Accordion>

</Accordion>

## Applying CRD

Once you have configured the InfisicalSecret CRD with the required fields, you can apply it to your cluster.
After applying, you should notice that the managed secret has been created in the desired namespace your specified.

```
kubectl apply -f example-infisical-secret-crd.yaml
```

To verify that the operator has successfully created the managed secret, you can check the secrets in the namespace that was specified.

```bash
# Verify managed secret is created
kubectl get secrets -n <namespace of managed secret>
```

<Info>
  The Infisical secrets will be synced and stored into the managed secret every
  1 minutes.
</Info>

## Using managed secret in your deployment

To make use of the managed secret created by the operator into your deployment can be achieved through several methods.
Here, we will highlight three of the most common ways to utilize it. Learn more about Kubernetes secrets [here](https://kubernetes.io/docs/concepts/configuration/secret/)

<Accordion title="envFrom">
  This will take all the secrets from your managed secret and expose them to your container

````yaml
  envFrom:
    - secretRef:
        name: managed-secret # managed secret name
  ```

  Example usage in a deployment
  ```yaml
  apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        envFrom:
        - secretRef:
            name: managed-secret # <- name of managed secret
        ports:
        - containerPort: 80
````

</Accordion>

<Accordion title="env"> 
  This will allow you to select individual secrets by key name from your managed secret and expose them to your container 
  
  ```yaml
  env:
    - name: SECRET_NAME # The environment variable's name which is made available in the container
      valueFrom:
        secretKeyRef:
          name: managed-secret # managed secret name
          key: SOME_SECRET_KEY # The name of the key which  exists in the managed secret
  ```

Example usage in a deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: nginx-deployment
labels:
app: nginx
spec:
replicas: 1
selector:
matchLabels:
app: nginx
template:
metadata:
labels:
app: nginx
spec:
containers: - name: nginx
image: nginx:1.14.2
env: - name: STRIPE_API_SECRET
valueFrom:
secretKeyRef:
name: managed-secret # <- name of managed secret
key: STRIPE_API_SECRET
ports: - containerPort: 80

```

</Accordion>

<Accordion title="volumes">
This will allow you to create a volume on your container which comprises of files holding the secrets in your managed kubernetes secret
```yaml
volumes:
  - name: secrets-volume-name # The name of the volume under which secrets will be stored
    secret:
      secretName: managed-secret # managed secret name
````

You can then mount this volume to the container's filesystem so that your deployment can access the files containing the managed secrets

```yaml
volumeMounts:
  - name: secrets-volume-name
    mountPath: /etc/secrets
    readOnly: true
```

Example usage in a deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:1.14.2
          volumeMounts:
            - name: secrets-volume-name
              mountPath: /etc/secrets
              readOnly: true
          ports:
            - containerPort: 80
      volumes:
        - name: secrets-volume-name
          secret:
            secretName: managed-secret # <- managed secrets
```

</Accordion>

The definition file of the Kubernetes secret for the CA certificate can be structured like the following:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: custom-ca-certificate
type: Opaque
stringData:
  ca.crt: |
    -----BEGIN CERTIFICATE-----
    MIIEZzCCA0+gAwIBAgIUDk9+HZcMHppiNy0TvoBg8/aMEqIwDQYJKoZIhvcNAQEL
    ...
    BQAwDTELMAkGA1UEChMCUEgwHhcNMjQxMDI1MTU0MjAzWhcNMjUxMDI1MjE0MjAz
    -----END CERTIFICATE-----
```

### Auto redeployment

Deployments using managed secrets don't reload automatically on updates, so they may use outdated secrets unless manually redeployed.
To address this, we added functionality to automatically redeploy your deployment when its managed secret updates.

#### Enabling auto redeploy

To enable auto redeployment you simply have to add the following annotation to the deployment that consumes a managed secret

```yaml
secrets.infisical.com/auto-reload: "true"
```

<Accordion title="Deployment example with auto redeploy enabled">
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
  annotations: 
    secrets.infisical.com/auto-reload: "true" # <- redeployment annotation
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        envFrom:
        - secretRef:
            name: managed-secret
        ports:
        - containerPort: 80
```
</Accordion>
<Info>
  #### How it works 
  When a secret change occurs, the operator will check to see which deployments are using the operator-managed Kubernetes secret that received the update. 
  Then, for each deployment that has this annotation present, a rolling update will be triggered.
</Info>

## Propagating labels & annotations

The operator will transfer all labels & annotations present on the `InfisicalSecret` CRD to the managed Kubernetes secret to be created.
Thus, if a specific label is required on the resulting secret, it can be applied as demonstrated in the following example:

<Accordion title="Example propagation">
```yaml
apiVersion: secrets.infisical.com/v1alpha1
kind: InfisicalSecret
metadata:
  name: infisicalsecret-sample
  labels:
    label-to-be-passed-to-managed-secret: sample-value
  annotations:
    example.com/annotation-to-be-passed-to-managed-secret: "sample-value"
spec:
  ..
  authentication:
    ...
  managedSecretReference:
    ...
```

This would result in the following managed secret to be created:

```yaml
apiVersion: v1
data: ...
kind: Secret
metadata:
  annotations:
    example.com/annotation-to-be-passed-to-managed-secret: sample-value
    secrets.infisical.com/version: W/"3f1-ZyOSsrCLGSkAhhCkY2USPu2ivRw"
  labels:
    label-to-be-passed-to-managed-secret: sample-value
  name: managed-token
  namespace: default
type: Opaque
```

</Accordion>
