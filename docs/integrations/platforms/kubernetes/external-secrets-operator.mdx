---
title: "External Secrets Operator"
sidebarTitle: "External Secrets Operator"
description: "Learn how to use External Secrets Operator (ESO) with Infisical to sync secrets into your Kubernetes cluster"
---

The [External Secrets Operator](https://external-secrets.io/) (ESO) is a Kubernetes operator that integrates external secret management systems like Infisical with Kubernetes. It reads information from external APIs and automatically injects the values into Kubernetes Secrets.

This guide walks you through setting up ESO with Infisical using Kubernetes Auth, which allows your applications to authenticate with Infisical using Kubernetes service account tokens without storing long-lived credentials.

<Note>
  If you prefer to use Infisical's native Kubernetes Operator instead of ESO, see the [Kubernetes Operator documentation](/integrations/platforms/kubernetes/overview).
</Note>

## Prerequisites

Before you begin, ensure you have:

- A Kubernetes cluster (v1.19+)
- `kubectl` configured to communicate with your cluster
- Helm v3 installed
- An Infisical account (cloud or self-hosted)
- A project in Infisical with secrets you want to sync

## Architecture Overview

When using ESO with Infisical Kubernetes Auth:

1. ESO reads the service account token from the pod
2. ESO sends the token to Infisical for authentication
3. Infisical validates the token with the Kubernetes API Server (TokenReview API)
4. If valid, Infisical returns an access token
5. ESO uses the access token to fetch secrets from Infisical
6. ESO creates/updates Kubernetes Secrets with the fetched data

## Step-by-Step Setup Guide

<Steps>
  <Step title="Install External Secrets Operator">
    First, install the External Secrets Operator in your cluster using Helm:

    ```bash
    # Add the External Secrets Helm repository
    helm repo add external-secrets https://charts.external-secrets.io
    helm repo update

    # Install the External Secrets Operator
    helm install external-secrets external-secrets/external-secrets \
      --namespace external-secrets \
      --create-namespace \
      --set installCRDs=true
    ```

    Verify the installation:

    ```bash
    kubectl get pods -n external-secrets
    ```

    You should see the external-secrets pods running.
  </Step>

  <Step title="Set up RBAC for Token Review">
    Infisical needs to validate service account tokens using the Kubernetes TokenReview API. Create a service account with the required permissions:

    ```yaml rbac-setup.yaml
    ---
    # Service account for Infisical to use for token review
    apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: infisical-token-reviewer
      namespace: default
    ---
    # ClusterRoleBinding to allow token review
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: infisical-token-reviewer-binding
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: system:auth-delegator
    subjects:
      - kind: ServiceAccount
        name: infisical-token-reviewer
        namespace: default
    ---
    # Long-lived token for the reviewer service account
    apiVersion: v1
    kind: Secret
    type: kubernetes.io/service-account-token
    metadata:
      name: infisical-token-reviewer-token
      namespace: default
      annotations:
        kubernetes.io/service-account.name: infisical-token-reviewer
    ```

    Apply the configuration:

    ```bash
    kubectl apply -f rbac-setup.yaml
    ```

    Retrieve the token reviewer JWT (you'll need this when configuring the Machine Identity in Infisical):

    ```bash
    kubectl get secret infisical-token-reviewer-token -n default -o=jsonpath='{.data.token}' | base64 --decode
    ```

    <Tip>
      Save this token securely. You'll need it in the next step when configuring Kubernetes Auth in Infisical.
    </Tip>
  </Step>

  <Step title="Create a Machine Identity in Infisical">
    Now create a Machine Identity in Infisical with Kubernetes Auth enabled:

    1. Navigate to your Infisical dashboard
    2. Go to **Organization Settings** > **Access Control** > **Identities**
    3. Click **Create Identity**
    4. Enter a name for the identity (e.g., "eso-kubernetes-auth")
    5. Select an organization role and click **Create**

    ![Create Identity](/images/platform/identities/identities-org-create.png)

    6. After creation, click on the identity to configure authentication
    7. Click **Add Auth Method** and select **Kubernetes Auth**

    ![Add Kubernetes Auth](/images/platform/identities/identities-org-create-kubernetes-auth-method.png)

    8. Configure the Kubernetes Auth settings:
       - **Kubernetes Host**: Your Kubernetes API server URL (get it with `kubectl cluster-info`)
       - **Token Reviewer JWT**: Paste the token from Step 2
       - **Allowed Service Account Names**: `external-secrets` (or your ESO service account name)
       - **Allowed Namespaces**: `external-secrets` (or the namespace where ESO is installed)
       - **CA Certificate**: (Optional) Your Kubernetes cluster CA certificate for TLS verification

    9. Click **Save**

    10. Copy the **Identity ID** - you'll need this for the SecretStore configuration

    <Note>
      Make sure to add the Machine Identity to the project(s) containing the secrets you want to sync. Go to **Project Settings** > **Access Control** > **Machine Identities** and add the identity with appropriate permissions (at minimum, read access to secrets).
    </Note>
  </Step>

  <Step title="Store the Identity ID in Kubernetes">
    Create a Kubernetes Secret containing the Infisical Machine Identity ID:

    ```yaml infisical-identity-secret.yaml
    apiVersion: v1
    kind: Secret
    metadata:
      name: infisical-kubernetes-auth
      namespace: external-secrets
    type: Opaque
    stringData:
      identityId: "<your-machine-identity-id>"
    ```

    Replace `<your-machine-identity-id>` with the Identity ID you copied in Step 3.

    Apply the secret:

    ```bash
    kubectl apply -f infisical-identity-secret.yaml
    ```
  </Step>

  <Step title="Create a SecretStore">
    Create a SecretStore that configures ESO to use Infisical with Kubernetes Auth:

    ```yaml secret-store.yaml
    apiVersion: external-secrets.io/v1
    kind: SecretStore
    metadata:
      name: infisical
      namespace: default
    spec:
      provider:
        infisical:
          # For Infisical Cloud, use: https://app.infisical.com
          # For self-hosted, use your instance URL
          hostAPI: https://app.infisical.com

          auth:
            kubernetesAuthCredentials:
              identityId:
                key: identityId
                name: infisical-kubernetes-auth
                namespace: external-secrets

          secretsScope:
            projectSlug: your-project-slug
            environmentSlug: dev  # "dev", "staging", "prod", etc.
            secretsPath: /
            recursive: false
            expandSecretReferences: true
    ```

    Update the following fields:
    - `hostAPI`: Your Infisical instance URL
    - `projectSlug`: Your Infisical project slug (found in Project Settings)
    - `environmentSlug`: The environment to fetch secrets from

    Apply the SecretStore:

    ```bash
    kubectl apply -f secret-store.yaml
    ```

    Verify the SecretStore is ready:

    ```bash
    kubectl get secretstore infisical -n default
    ```

    The status should show `Valid: True`.
  </Step>

  <Step title="Create an ExternalSecret">
    Now create an ExternalSecret to sync secrets from Infisical to a Kubernetes Secret:

    ```yaml external-secret.yaml
    apiVersion: external-secrets.io/v1
    kind: ExternalSecret
    metadata:
      name: my-app-secrets
      namespace: default
    spec:
      refreshInterval: 1h
      secretStoreRef:
        kind: SecretStore
        name: infisical
      target:
        name: my-app-secrets  # Name of the Kubernetes Secret to create
        creationPolicy: Owner
      # Option 1: Fetch all secrets
      dataFrom:
        - find:
            name:
              regexp: ".*"
      # Option 2: Fetch specific secrets (uncomment to use)
      # data:
      #   - secretKey: DATABASE_URL
      #     remoteRef:
      #       key: DATABASE_URL
      #   - secretKey: API_KEY
      #     remoteRef:
      #       key: API_KEY
    ```

    Apply the ExternalSecret:

    ```bash
    kubectl apply -f external-secret.yaml
    ```

    Verify the ExternalSecret is syncing:

    ```bash
    kubectl get externalsecret my-app-secrets -n default
    ```

    The status should show `SecretSynced: True`.
  </Step>

  <Step title="Verify the Setup">
    Check that the Kubernetes Secret was created with your Infisical secrets:

    ```bash
    # List the secret
    kubectl get secret my-app-secrets -n default

    # View the secret keys (values are base64 encoded)
    kubectl get secret my-app-secrets -n default -o jsonpath='{.data}' | jq

    # Decode a specific value
    kubectl get secret my-app-secrets -n default -o jsonpath='{.data.YOUR_SECRET_KEY}' | base64 --decode
    ```
  </Step>
</Steps>

## Using a ClusterSecretStore

If you need to share the same Infisical configuration across multiple namespaces, use a `ClusterSecretStore` instead:

```yaml cluster-secret-store.yaml
apiVersion: external-secrets.io/v1
kind: ClusterSecretStore
metadata:
  name: infisical-cluster
spec:
  provider:
    infisical:
      hostAPI: https://app.infisical.com
      auth:
        kubernetesAuthCredentials:
          identityId:
            key: identityId
            name: infisical-kubernetes-auth
            namespace: external-secrets  # Required for ClusterSecretStore
      secretsScope:
        projectSlug: your-project-slug
        environmentSlug: dev
        secretsPath: /
        recursive: false
        expandSecretReferences: true
```

Then reference it in your ExternalSecret:

```yaml
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: my-app-secrets
  namespace: my-namespace
spec:
  secretStoreRef:
    kind: ClusterSecretStore
    name: infisical-cluster
  # ... rest of the configuration
```

## Self-Hosted Infisical with Custom CA

If you're using a self-hosted Infisical instance with a self-signed certificate or private CA, configure the CA certificate:

### Using caBundle (inline)

```yaml
apiVersion: external-secrets.io/v1
kind: SecretStore
metadata:
  name: infisical
spec:
  provider:
    infisical:
      hostAPI: https://your-infisical-instance.com
      # Base64-encoded PEM certificate
      caBundle: "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0t..."
      auth:
        kubernetesAuthCredentials:
          identityId:
            key: identityId
            name: infisical-kubernetes-auth
            namespace: external-secrets
      secretsScope:
        projectSlug: your-project-slug
        environmentSlug: dev
```

### Using caProvider (from Secret)

```yaml
apiVersion: external-secrets.io/v1
kind: SecretStore
metadata:
  name: infisical
spec:
  provider:
    infisical:
      hostAPI: https://your-infisical-instance.com
      caProvider:
        type: Secret
        name: infisical-ca
        key: ca.crt
      auth:
        kubernetesAuthCredentials:
          identityId:
            key: identityId
            name: infisical-kubernetes-auth
            namespace: external-secrets
      secretsScope:
        projectSlug: your-project-slug
        environmentSlug: dev
```

## Other Authentication Methods

ESO supports multiple authentication methods with Infisical. Here are examples for other common methods:

<Accordion title="Universal Auth">
  Universal Auth uses a client ID and client secret for authentication:

  ```yaml
  # Create the credentials secret
  apiVersion: v1
  kind: Secret
  metadata:
    name: universal-auth-credentials
    namespace: external-secrets
  type: Opaque
  stringData:
    clientId: "<your-client-id>"
    clientSecret: "<your-client-secret>"
  ---
  # SecretStore configuration
  apiVersion: external-secrets.io/v1
  kind: SecretStore
  metadata:
    name: infisical
  spec:
    provider:
      infisical:
        hostAPI: https://app.infisical.com
        auth:
          universalAuthCredentials:
            clientId:
              key: clientId
              name: universal-auth-credentials
              namespace: external-secrets
            clientSecret:
              key: clientSecret
              name: universal-auth-credentials
              namespace: external-secrets
        secretsScope:
          projectSlug: your-project-slug
          environmentSlug: dev
          secretsPath: /
  ```
</Accordion>

<Accordion title="AWS IAM Auth">
  For workloads running on AWS with IAM roles:

  ```yaml
  apiVersion: v1
  kind: Secret
  metadata:
    name: aws-auth-credentials
    namespace: external-secrets
  type: Opaque
  stringData:
    identityId: "<your-machine-identity-id>"
  ---
  apiVersion: external-secrets.io/v1
  kind: SecretStore
  metadata:
    name: infisical
  spec:
    provider:
      infisical:
        hostAPI: https://app.infisical.com
        auth:
          awsAuthCredentials:
            identityId:
              key: identityId
              name: aws-auth-credentials
              namespace: external-secrets
        secretsScope:
          projectSlug: your-project-slug
          environmentSlug: dev
          secretsPath: /
  ```
</Accordion>

<Accordion title="GCP ID Token Auth">
  For workloads running on GCP:

  ```yaml
  apiVersion: v1
  kind: Secret
  metadata:
    name: gcp-auth-credentials
    namespace: external-secrets
  type: Opaque
  stringData:
    identityId: "<your-machine-identity-id>"
  ---
  apiVersion: external-secrets.io/v1
  kind: SecretStore
  metadata:
    name: infisical
  spec:
    provider:
      infisical:
        hostAPI: https://app.infisical.com
        auth:
          gcpIdTokenAuthCredentials:
            identityId:
              key: identityId
              name: gcp-auth-credentials
              namespace: external-secrets
        secretsScope:
          projectSlug: your-project-slug
          environmentSlug: dev
          secretsPath: /
  ```
</Accordion>

<Accordion title="Azure Auth">
  For workloads running on Azure:

  ```yaml
  apiVersion: v1
  kind: Secret
  metadata:
    name: azure-auth-credentials
    namespace: external-secrets
  type: Opaque
  stringData:
    identityId: "<your-machine-identity-id>"
  ---
  apiVersion: external-secrets.io/v1
  kind: SecretStore
  metadata:
    name: infisical
  spec:
    provider:
      infisical:
        hostAPI: https://app.infisical.com
        auth:
          azureAuthCredentials:
            identityId:
              key: identityId
              name: azure-auth-credentials
              namespace: external-secrets
        secretsScope:
          projectSlug: your-project-slug
          environmentSlug: dev
          secretsPath: /
  ```
</Accordion>

## Troubleshooting

<AccordionGroup>
  <Accordion title="SecretStore shows 'Invalid' status">
    Check the SecretStore events for more details:

    ```bash
    kubectl describe secretstore infisical -n default
    ```

    Common issues:
    - Incorrect Identity ID
    - Machine Identity not added to the project
    - Incorrect project slug or environment slug
    - Network connectivity issues to Infisical
  </Accordion>

  <Accordion title="ExternalSecret not syncing">
    Check the ExternalSecret status and events:

    ```bash
    kubectl describe externalsecret my-app-secrets -n default
    ```

    Verify the SecretStore is valid first:

    ```bash
    kubectl get secretstore infisical -n default
    ```
  </Accordion>

  <Accordion title="Authentication failures">
    Ensure:
    - The service account name in the SecretStore matches the allowed service accounts in Infisical
    - The namespace matches the allowed namespaces in Infisical
    - The Token Reviewer JWT is valid and has the `system:auth-delegator` role
    - The Kubernetes API server is accessible from Infisical (for self-hosted)
  </Accordion>

  <Accordion title="Secrets not appearing in Kubernetes">
    Check if the secret exists:

    ```bash
    kubectl get secret my-app-secrets -n default
    ```

    If it doesn't exist, check the ExternalSecret status. If it exists but is empty, verify:
    - The secrets exist in Infisical at the specified path
    - The Machine Identity has read access to the secrets
    - The `dataFrom` or `data` configuration matches your secrets
  </Accordion>
</AccordionGroup>

## Complete Example

Here's a complete set of YAML files you can use as a starting point:

<Accordion title="Complete YAML Configuration">
  Save this as `infisical-eso-setup.yaml`:

  ```yaml
  ---
  # 1. RBAC for Token Review (apply to your cluster)
  apiVersion: v1
  kind: ServiceAccount
  metadata:
    name: infisical-token-reviewer
    namespace: default
  ---
  apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRoleBinding
  metadata:
    name: infisical-token-reviewer-binding
  roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: ClusterRole
    name: system:auth-delegator
  subjects:
    - kind: ServiceAccount
      name: infisical-token-reviewer
      namespace: default
  ---
  apiVersion: v1
  kind: Secret
  type: kubernetes.io/service-account-token
  metadata:
    name: infisical-token-reviewer-token
    namespace: default
    annotations:
      kubernetes.io/service-account.name: infisical-token-reviewer
  ---
  # 2. Identity ID Secret (update with your Identity ID)
  apiVersion: v1
  kind: Secret
  metadata:
    name: infisical-kubernetes-auth
    namespace: external-secrets
  type: Opaque
  stringData:
    identityId: "YOUR_IDENTITY_ID_HERE"
  ---
  # 3. SecretStore (update with your project details)
  apiVersion: external-secrets.io/v1
  kind: SecretStore
  metadata:
    name: infisical
    namespace: default
  spec:
    provider:
      infisical:
        hostAPI: https://app.infisical.com
        auth:
          kubernetesAuthCredentials:
            identityId:
              key: identityId
              name: infisical-kubernetes-auth
              namespace: external-secrets
        secretsScope:
          projectSlug: YOUR_PROJECT_SLUG
          environmentSlug: dev
          secretsPath: /
          recursive: false
          expandSecretReferences: true
  ---
  # 4. ExternalSecret (update with your secret names)
  apiVersion: external-secrets.io/v1
  kind: ExternalSecret
  metadata:
    name: my-app-secrets
    namespace: default
  spec:
    refreshInterval: 1h
    secretStoreRef:
      kind: SecretStore
      name: infisical
    target:
      name: my-app-secrets
      creationPolicy: Owner
    dataFrom:
      - find:
          name:
            regexp: ".*"
  ```

  Apply with:

  ```bash
  kubectl apply -f infisical-eso-setup.yaml
  ```
</Accordion>

## Next Steps

- Learn more about [Machine Identities](/documentation/platform/identities/machine-identities) in Infisical
- Explore [Kubernetes Auth](/documentation/platform/identities/kubernetes-auth) configuration options
- Check out the [External Secrets Operator documentation](https://external-secrets.io/latest/provider/infisical/) for advanced features
